=head0 Lists

=head1 Overview plan

    - Singly-linked lists
        - some characteristics
        - how they are formed
        - basic implementation (in Perl)
    - Indexing into a list
    - Interlude: Tail recursion, TCE
    - List operations
        - map / fmap
        - filter
        - fold
    - Modifying, inserting, deleting list elements
        - mutable versus immutable
        - compare with a mutable Vector (such as Perl's arrays)
    - Copying lists
        - how to deep copy an immutable data-structure ;-)
        - caching Empty (MooseX::Singleton)
        - caching generally (Memoize?)
    - Infinite lists
        - laziness
        - implementation
    - Doubly-linked lists?
        - mutable... immutable?
        - pointers
        - code
        - rewrite with Data::Zipper

    - Exercise: implement a turing machine with a zipper onto an infinite
        (in both directions) list

    - Show me the Code!: implementations of the above concepts
      (or, if available, usages of equivalent, available library functions)
        - Modern Perl with Moose
        - Javascript
        - Ruby
        - Python

=head1 Linked lists

The linked list is one of the oldest data structures in computing, dating
back to the mid-1950s.  While it's a collection type, similar to an Array,
it makes very different tradeoffs.

In a dynamic programming language like Perl, Ruby, Python, of Javascript,
we very rarely feel the need to look beyond the builtin array types, as they
are usually Good Enough.  However, the linked list I<is> a fundamental building
block, and we'll see that it is key for understanding concepts such as:

=over 4

=item recursive thinking

=item data-sharing

=item persistent data structures

=back

Beyond this, linked lists do have some features that arrays don't

=over 4

=item handling circular data

=item infinite lists and streams

=item possibility for automatic parallelisation

=back

A linked list is a structure that contains an element (often called the
C<head>) and a pointer to the rest of the list (the C<tail>).

For example, the word C<"hello"> is made up of the list of characters:

    [h.]->[e.]->[l.]->[l.]->[o ]
     ^    ^
   head   tail

The head is the letter C<"h">, and the tail is the list

    [e.]->[l.]->[l.]->[o ]

So we've seen lists of 4 and 5 elements.  You could grow the list arbitrarily
large, by continuing to add links to new elements.  

How about smaller lists?

    1 element:   [o ]
    0 elements:  ()

The 0-element list doesn't have a head or a tail.  It's just an empty list.
But how about the 1-element list?  It has a C<head>, but does it have a
C<tail>?

Well, we saw that the tail of the list C<"hello"> was the list C<"ello">.
So the tail of C<"o"> should be the list C<"">, i.e. the empty list.

This means that really our lists look like:

    [o.]->()

    [h.]->[e.]->[l.]->[l.]->[o.]->()

Which means that all lists have a head I<and> a tail. Unless they're the empty
list, which has neither.  i.e. a list can be one of two things:

    ()      the empty list
    [x.]->  a linking cell the connects a value to another list
            (where the other list is either another linking cell
            or an empty list)

=head1 Implementation

Let's have a look now at how we could represent this in code.  As usual,
we'll look at examples in Modern Perl.  We'll add code and explanations in
Ruby, Python, and JavaScript at the end of the chapter.

We I<could> represent the two cases as

    []              an empty array
    [$head, $tail]  an array representing a tuple of head and tail

However, in this book we'll use objects declared using C<Moose> wherever we
can.  This will give more straight-forward code, as well as having a lot of
power that we'll need when we go on to more complex scenarios.

Note that all of the code examples are implemented and tested at 
C<https://github.com/osfameron/pure-fp-book/tree/master/code>, so you can
easily check how things hang together. If there's no implementation in your
language, then please fork the code on github and contribute!

As we saw, there are two types of list.  From an Object Oriented perspective,
we might think of implementing this with an Abstract Base Class (i.e. one that
only acts as a superclass, to tie together related functionality and type
information, but which can't be instantiated into a C<-E<gt>new> object; and
then with concrete subclasses.  The Moosey way to do this is to use a C<Role>
(also known as a trait, and similar in many ways to Ruby's mixins).

    use MooseX::Declare;
    BEGIN { role_type 'List' }

    role List {
        requires 'head';
        requires 'tail';
    }

    class List::Link with List {
        has head => ( is => 'ro', isa => 'Any' );
        has tail => ( is => 'ro', isa => 'List' ),
    }

    class List::Empty with List {
        method head { die "Can't take head of empty list!" }
        method tail { die "Can't take tail of empty list!" }
    }

With this code, we could already create a list, but it'd be a little verbose:

    my $list = List::Link->new(
        head => 'h',
        tail => List::Link->new(
            head => 'e',
            tail => List::Link->new(...

So let's add a little sugar.  We'll create a function C<fromArray> that we'll
call like so:

    my $list = List->fromArray( 1..10 );

As lists are a recursive data structure, it makes sense to implement this in
a recursive way so:

=over

=item * 

If the array is empty, we return an empty list.  

=item * 

If the array has one element, we'll link that with the empty list

=item * 

... and, in general, we'll link the first element in the array with the result
of calling C<fromArray> on the remainder of the array.

=back

Typically in Perl we might use a condition like C<if> to distinguish between
these cases.  But in both Functional and Object Oriented programming, it's
often much more elegant to use pattern matching (of which "multiple dispatch"
is a variant.) C<Moose> provides a rather nice and flexible way of declaring
these, and we'll take advantage of it.

    use MooseX::MultiMethods;

    # can be called as a class method, or on an object
    multi method fromArray ($class:) {
        return List::Empty->new;
    }
    multi method fromArray ($class: $head, @tail) {
        return List::Link->new(
            head => $head,
            tail => $class->fromArray(@tail),
        );
    }

This kind of recursive code is very elegant.  But there is a teensy little
problem: dynamic languages were never designed for this kind of code structure,
and that means that, by default, they do have a few little hiccups that we need
to be aware of.

=head2 Tail calls and recursion limits

In the method C<fromArray> above, we recurse back into the same method until
we've converted all the elements of the array into a List.  Every time we do
this, we are making a new method call, which is added to the call stack.  This
requires storing information about the caller, and to support these very
dynamic languages, may require quite a I<lot> of information... And finally,
once we get to the base case, and are ready to return the result, the
interpreter will then have to hop back through the stack, one level at a time,
till it gets back to the top, passing the result information up all the way to
the top.

If we make many of these recursive calls, then the interpreter may start to
complain about what we're doing.  For example, in Perl:

    Deep recursion on subroutine "List::fromArray" at foo.pl line 20

There are ways to eliminate these warnings

    no warnings 'recursion';
    $DB::deep = 100_000_000; # some big number, greater than maximum 
                             # number of recursions

But that would only be papering over the synptoms, the root problem would
remain: we may blow all the memory allocated to the call stack, and the
interpreter may crash.

In languages like Scheme and Haskell, which are built around recursive data
structures, the compilers will naturally do Tail Call Elimination. This means
that if the last action in a routine is to call another method (often, but not
always, the current method) then you can simply jump to that method, without
having to add the overhead of storing the call on the stack.

Though Perl can't (yet?) do this kind of optimization automatically, there are
two modules on CPAN by Yuval Koogman that will allow you to handle this
elegantly, C<Sub::Call::Tail> and C<Sub::Call::Recur>.  The latter is faster,
but only handles function calls that recurse into themselves.  The former can
handle tail calls to any subroutine, and also object methods, so we'll use
that.

By default, C<Sub::Call::Tail> exports a function called C<tail>.  As our List
class already has a method C<tail> (meaning something quite different), this
could confuse both the reader and C<perl> itself.  So we'll take advantage of
the facility to import an aliased function, and call it C<tail_call> instead,
which makes it much clearer!

 # the slightly nicer 'use' line is implemented in 
 # https://github.com/osfameron/sub-call-tail release pending ;-)

    # take that, recursion!
    use Sub::Import 'Sub::Call::Tail' tail => { -as => 'tail_call' };
    # use Sub::Call::Tail tail => { -as => 'tail_call'};

    multi method fromArray ($self: $head, @tail) {
        tail_call List::Link->new(
            head => $head,
            tail => $self->fromArray(@tail),
        );
    }

There are similar workarounds available for Python, Ruby, and Javascript.  They
will usually use a C<goto> statement in some form, perhaps a structured one
that either jumps back to the beginning of the block.  

(Interestingly, though the Perl hack in C<Sub::Call::Tail> is implemented with
a C<goto &function> call, which shares the same name as the reviled
control-flow operation, it's substantially cleaner than you might fear.  This
type of C<goto> simply replaces the currently running subroutine with
a new one, a little like Unix's C<exec> switches to a new process.)

=head2 Getting data out of a list 

=head3 Indexing into the list

While arrays and lists both store collections of data, the representations make
certain tasks easier or more difficult.  Accessing an item positionally, for
example, is trivial with an array:

     0  1  2  3  4 
    [h][e][l][l][o]

    To access item number 3, find the beginning of the array, and get the 
    contents of the box 3 positions to the right.

With a list, on the other hand, we don't have an easy way to jump to another
element, as each cell is stored in a different location in memory.

    [h.]->[e.]->[l.]->[l.]->[o.]->()

Instead we need to visit each cell in turn until we arrive at the right C<head>
element.

Obviously, we can't index into an Empty list:

    multi method nth (List::Empty $self: Int $pos) { 
        die "Can't index into an Empty list"; 
    }

And if we want the zero-th element of a list, then we're just looking for its
head.

    multi method nth (Int $pos where { $_ == 0 }) {
        return $self->head;
    }

But if we've passed a positive integer, then we can simply recurse down the
tail, looking for the C<nth> of the next lowest integer, until we get to 0.

    multi method nth (Int $pos where { $_ > 0 }) {
        tail_call $self->tail->nth( $pos - 1 );
    }

Notice how we've specified all the valid ways to call this method.  If we call
C<$list-E<gt>nth("foo")> or C<$list-E<gt>nth(-1)> then Moose will throw an
error for us automatically!

=head3 Converting back to array

It may sometimes be convenient to flatten our List structure back to a native
array.  We could do this again with recursion.

    multi method toArray_recursive (List::Empty $self:) { 
        return ()
    }
    multi method toArray_recursive (List::Link $self:) {
        return ($self->head, $self->tail->toArray_recursive);
    }

But notice how we don't have a convenient function to make a tail call on. The
C<toArray> method is called, but as I<part> of the expression only.  In general,
there are two ways to handle this: 

=over

=item * 

convert the function into a tail-recursive one, by extracting out the stack

=item * 

convert the function into an iterative one, that manages its own stack

=back

The best general tutorial to these methods using a dynamic programming language
may well be Mark Jason Dominus's I<Higher Order Perl>, now freely available
online at http://hop.perl.plover.com/ (though it's worth buying, whatever your
programming language of choice).

We'll just briefly look at an example of each technique.

=head3 converting the function into a tail-recursive one

We'll need to extract the returned C<@array> and instead pass it onwards within
the tail call.

    multi method toArray_stack (List::Empty $self: @stack) {
        return @stack;
    }
    multi method toArray_stack (List::Link $self: @stack) {
        tail_call $self->tail->toArray_stack(@stack, $self->head);
    }

=head3 converting the function into an iterative one

Here we will entirely eschew the idea of making a recursive function call, and
instead loop through the list using a classic imperative programming statement,
the C<while> loop.  We'll also manage our own stack, as a variable C<@stack>.

    method toArray_iterative () {
        my @stack;
        my $list = $self;
        while ($list->isa('List::Link')) {
            push @stack, $list->head;
            $list = $list->tail;
        }
        return @stack;
    }

=head2 Transformations on lists

Every standard library for manipulating lists should come with a number of basic
transformations, for mapping all the values with a function, filtering them
according to some criteria, or reducing the collection to a single value. We'll
look at each of these in turn.

=head3 Applying a function to a list: C<map>

We often want to apply a function to all elements of a collection.  For
example, we may have a list of user records, and we want a list of full names.

The dynamic languages, for the most part, have already borrowed this
functionality from the world of Functional Programming, and often call it
C<map>.

    my @users = (
        {
            first_name => 'Bob',
            last_name  => 'Smith',
        },
        {
            first_name => 'Aisha',
            last_name  => 'Chaudhury',
        }
    );

    use signatures;
    sub full_name ($user) {
        return join ' ' => 
            $user->{first_name},
            $user->{last_name};
    }

    my @full_names = map full_name($_), @users;

To define map for a linked list, we of course define it recursively!

    multi method map (List::Empty $self: CodeRef $f) { 
        return $self;
    }
    multi method map (List::Link $self: CodeRef $f) {
        tail_call $self->new( 
            head => $f->($self->head),
            tail => $self->tail->map( $f )
        );
    }

and later:

    my $users = List->fromArray(@users);

    my $names = $users->map( \&full_name );

=head4 Functors

Note how we started with a function that operated on a single value:

    full_name :: { first_name, last_name } -> "Full name"

And we've ended with one that operates on whole collections:

    map(full_name) :: [List of {...}] -> [List of "Full name"]

Often, in the world of FP, we'll call this kind of operation a Functor.  You'll
often see the operation that we just defined as C<map> called C<fmap> instead
(i.e. Functor Map).  Converting a function that operates on a single value to
one that operates on a collection (or any other type of container) is called
I<lifting> the function.

=head3 C<filter>ing the list

Another key operation on any collection type is to filter them by some criteria.
All the dynamic languages offer this facility for their native types, usually
calling them C<grep> or C<filter>, or in some cases using a more general
facility called List Comprehensions.  We'll implement the simple filter case,
again recursively.

    multi method filter (List::Empty $self: CodeRef $f) { 
        return $self;
    }
    multi method filter (List::Link $self: CodeRef $f) {
        my $head = $self->head;
        if ($f->($head)) {
            tail_call $self->new( 
                head => $head,
                tail => $self->tail->filter( $f ),
            );
        }
        else {
            tail_call $self->tail->filter( $f );
        }
    }

So, we could now write

    # TODO TEST
    use signatures;
    my $odd_numbers = List->fromArray(1..100)->filter(
        sub ($n) { $n % 2 }
    );

=head3 C<fold>

Folds are the result of repeatedly applying an operation to every pair of
values in a List until you get a single value.  An example could be finding the
sum of a list of numbers.

    sum (1,2,3,4,5) = 1 + 2 + 3 + 4 + 5

We could think of the sum as:

    1 + (2 + (3 + (4 + 5))) <-- a right fold

or as

    (((1 + 2) + 3) + 4) + 5 <-- a left fold

Oddly, these two folds, C<foldr> and C<foldl> have rather different
characteristics: sometimes one will be faster, or will never complete.

With all these recursive algorithms, we have to consider the "base case",
which for lists means "what happens with an empty list?"  The typical way
to do this is to also include a parameter which is an I<identity> value.
For a C<sum> operation, this would be C<0>.

    sub add ($x,$y) { $x + $y },
    sub sum ($nums) {
        return $nums->fold( \&add, 0 );
    }

Whereas for a multiplicative C<product> it would be C<1>

    sub multiply ($x,$y) { $x * $y },
    sub product ($nums) {
        return $nums->fold( \&multiply, 1 );
    }

Though in both these cases, the fold's input and output are the same type of
value, folds allow the result to be a different type entirely.  In general, we
call the result an I<accumulator>, as it accumulates the folder data as we
progress through the list.

Let's have a look at the left-fold first.

    multi method foldl (List::Empty $self: CodeRef $f, $acc) {
        return $acc;
    }
    multi method foldl (List::Link $self: CodeRef $f, $acc) {
        tail_call $self->tail->foldl($f, $f->($self->head, $acc));
    }

So the left fold is a typical recursive function.  Note how we have to pass
the accumulator to the first call - often we'd call this the I<init> argument.

While it's easy to see what the init argument should be, in many cases, you
may have noticed that my original example omitted one:

    sum (1,2,3,4,5) = 1 + 2 + 3 + 4 + 5

In this case we can simply use the first element in the list to start things
off.  This obviously wouldn't work for an empty list!  Often such a fold is
labelled with the number C<1>:

    # TODO test
    method foldl1 (List::Link $self: CodeRef $f, $acc) {
        return $self->tail->foldl($f, $self->head);
    }

As we've specified that C<$self> must be a linking list, the method will fail
entirely on an empty list.

# TODO case where we have an accumulator, rather than a typical binop

Now let's have a look at a right fold.  The empty case is, of course, the same:

    multi method foldr (List::Empty $self: CodeRef $f, $acc) {
        return $acc;
    }

But note how, unlike C<foldl>, the right fold isn't tail recursive:

    multi method foldr (List::Link $self: CodeRef $f, $acc) {
        tail_call $f->(
            $self->head,
            $self->tail->foldr($f, $acc),
        );
    }

Though we have a tail call, it's only on the folding function C<$f>.  The
actual call back into C<foldr> isn't in the tail position, where it can be
easily optimized, but rather I<inside> the call to this folding function.

=over

=item * EXERCISE:

Try to optimize C<foldr> by making it tail-recursive or iterative, as
we saw above with C<toArray>

=back

Later, when we look at infinite lazy lists, we'll come back to another little
tweak that languages like Haskell use to optimize right folds.

=head2 Modifying the list (editing, inserting, deleting)

=head3 How is a list different to an array

We noted earlier that an array was represented as a contiguous area of memory
while a list is a series of nodes that point to each other

    ARRAY:
     0  1  2  3  4 
    [h][e][l][l][o]

    LIST
    0     1     2     3     4     5
    [h.]->[e.]->[l.]->[l.]->[o.]->()

We saw above that the code to access the C<nth> element of a list was rather
more complicated than for an array.  Similarly, other operations are more
(or less) complicated.

If we want to change our list to C<"hullo"> instead, then this is easy with
an array.

    $array[1] = "u";

    ARRAY is now:
    [h][u][l][l][o]

Of course we've now "lost" the original representation of "hello", because
the contents of that array have been entirely written over.  Now, we might
want to do the same thing with a list

    $list->mutateAt(1, 'u');

    LIST
    0     1     2     3     4     5
    [h.]->[u.]->[l.]->[l.]->[o.]->()
           ^
           changed in-place

And of course we'd do it recursively:
    
    # NOT TESTED
    multi method mutateAt (List::Empty $self: Int $pos, $new) { 
        die "Can't mutate an Empty list"; 
    }
    multi method mutateAt (Int $pos where { $_ == 0 }, $new) {
        $self->head($new);
    }
    multi method mutateAt (Int $pos where { $_ > 0 }, $new) {
        tail_call $self->tail->mutateAt($pos - 1, $new);
    }

However, that would be a I<mutation> of a value, and in this book, we're mostly
interested in I<immutable>, pure data structures.  Note that we even declared
our attributes with read-only (C<'ro'>) accessors.  

    class List::Link with List {
        has head => ( is => 'ro', isa => 'Any' );
        has tail => ( is => 'ro', isa => 'List' ),
    }

If we relax these to C<'rw'>, we could make the C<mutateAt> code work.  This is
how you might typically work with linked lists in a language like C<C>.  But
of course such a list shares the disadvantage of the array mutation - that we
have now lost the original C<"hello"> sequence.  Let's see if we can do better.

So, we want to retain the C<'e'> node, but avoid it, like so:

    LIST
    0     1     2     3     4     5
    [h.]->[e.]->[l.]->[l.]->[o.]->()
        \     /
          [u.]

But of course the node C<'h'> can't point to two tails!  So we could relink it
entirely:

    LIST
    0     1     2     3     4     5
          [e.]->[l.]->[l.]->[o.]->()
              /
    [h.]->[u.]

But now we have no way of getting at the original list at all.  The solution 
turns out to be to I<copy> everything before the element we're changing.

    LIST
    0     1     2     3     4     5
    [h.]->[e.]->[l.]->[l.]->[o.]->()
              /
    [h.]->[u.]

We now have I<2> nodes that contain the value C<'h'> in their head, but which
have entirely different tails.  Note, though, that they converge at C<'l'>,
so we only need to copy part of the list.

    # NOT TESTED
    multi method updateAt (List::Empty $self: Int $pos, $new) { 
        die "Can't update an Empty list"; 
    }
    multi method updateAt (Int $pos where { $_ == 0 }, $new) {
        List::Link->new({
            head => $new,
            tail => $self->tail,
        });
    }
    multi method updateAt (Int $pos where { $_ > 0 }, $new) {
        tail_call List::Link->new({
            head => $self->head,
            tail => $self->tail->updateAt($pos - 1, $new);
        });
    }

Once we get to position 0 we simply return a list with the modified value as
its head, but the same tail as before.

All this copying may seem inefficient.  If you have to do multiple updates,
then you will end up copying at least the I<beginning> of the list each time.
Tellingly, Haskell's I<Prelude> (the standard library) missed out C<updateAt>
from its very rich set of functions that manipulate linked lists.

In fact, a linked list, by default isn't the optimal structure for random
access.  However, we have seen that the benefit of using an immutable structure
is that we get to keep the old and new versions of a structure at the same
time, and with minimal memory usage, because of the sharing of data between the
two structures.

This technique of data sharing where possible (and cloning with updated values
where not) will be a common tool, so it is worth getting to grips with this
simple example first, so we'll look now at inserting and deleting elements from
a list.

Of course, other data structures may well be more appropriate for your task,
for example:

=over

=item * Array

Yes, they're mutable, but in some cases, they will still be the appropriate
structure.

=item * Zippers

We'll look at these shortly - these allow us to update a list immediately, in
place, in constant time.  Especially useful if you will be doing multiple
updates.

=item * Trees

We'll look at these in detail in the next chapter

=back

=cut
