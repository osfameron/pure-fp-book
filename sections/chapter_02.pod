=head0 Lists

=head1 Overview plan

    - Singly-linked lists
        - some characteristics
        - how they are formed
        - basic implementation (in Perl)
    - Indexing into a list
    - Interlude: Tail recursion, TCE
    - List operations
        - map / fmap
        - filter
        - fold
    - Modifying, inserting, deleting list elements
        - mutable versus immutable
        - compare with a mutable Vector (such as Perl's arrays)
    - Copying lists
        - how to deep copy an immutable data-structure ;-)
        - caching Empty (MooseX::Singleton)
        - caching generally (Memoize?)
    - Infinite lists
        - laziness
        - implementation
    - Doubly-linked lists?
        - mutable... immutable?
        - pointers
        - code
        - rewrite with Data::Zipper

    - Exercise: implement a turing machine with a zipper onto an infinite
        (in both directions) list

    - Show me the Code!: implementations of the above concepts
      (or, if available, usages of equivalent, available library functions)
        - Modern Perl with Moose
        - Javascript
        - Ruby
        - Python

=head1 Linked lists

The linked list is one of the oldest data structures in computing, dating
back to the mid-1950s.  While it's a collection type, similar to an Array,
it makes very different tradeoffs.

In a dynamic programming language like Perl, Ruby, Python, of Javascript,
we very rarely feel the need to look beyond the builtin array types, as they
are usually Good Enough.  However, the linked list I<is> a fundamental building
block, and we'll see that it is key for understanding concepts such as:

=over 4

=item recursive thinking

=item data-sharing

=item persistent data structures

=back

Beyond this, linked lists do have some features that arrays don't

=over 4

=item handling circular data

=item infinite lists and streams

=item possibility for automatic parallelisation

=back

A linked list is a structure that contains an element (often called the
C<head>) and a pointer to the rest of the list (the C<tail>).

For example, the word C<"hello"> is made up of the list of characters:

    [h.]->[e.]->[l.]->[l.]->[o ]
     ^    ^
   head   tail

The head is the letter C<"h">, and the tail is the list

    [e.]->[l.]->[l.]->[o ]

So we've seen lists of 4 and 5 elements.  You could grow the list arbitrarily
large, by continuing to add links to new elements.  

How about smaller lists?

    1 element:   [o ]
    0 elements:  ()

The 0-element list doesn't have a head or a tail.  It's just an empty list,
which is a different case to what we've seen.  But how about the 1-element
list?  It has a C<head>, but does it have a C<tail>?

Well, we saw that the tail of the list C<"hello"> was the list C<"ello">.
So the tail of C<"o"> should be the list C<"">, i.e. the empty list.

This means that really our lists look like:

    [o.]->()

    [h.]->[e.]->[l.]->[l.]->[o.]->()

So a list can be one of two things:

    ()      an empty list
    [x.]->  a linking cell the connects a value to another list
            (where the other list is either another linking cell
            or an empty list)

=head1 Implementation

Let's have a look now at how we could represent this in code.  As usual,
we'll look at examples in Modern Perl.  We'll add code and explanations in
Ruby, Python, and JavaScript at the end of the chapter.

We I<could> represent the two cases as

    []              an empty array
    [$head, $tail]  an array representing a tuple of head and tail

However, in this book we'll use objects declared using C<Moose> wherever we
can.  This will give more straight-forward code, as well as having a lot of
power that we'll need when we go on to more complex scenarios.

Note that all of the code examples are implemented and tested at 
C<https://github.com/osfameron/pure-fp-book/tree/master/code>, so you can
easily check how things hang together. If there's no implementation in your
language, then please fork the code on github and contribute!

    use MooseX::Declare;
    BEGIN { role_type 'List' }

    role List {
        requires 'head';
        requires 'tail';
    }

    class List::Link with List {
        has head => ( is => 'ro', isa => 'Any' );
        has tail => ( is => 'ro', isa => 'List' ),
    }

    class List::Empty with List {
        method head { die "Can't take head of empty list!" }
        method tail { die "Can't take tail of empty list!" }
    }

With this code, we could already create a list, but it'd be a little verbose:

    my $list = List::Link->new(
        head => 'h',
        tail => List::Link->new(
            head => 'e',
            tail => List::Link->new(...

So let's add a little sugar.  If the array is empty, we return an empty list.
Otherwise we create a link from the first element of the array to the rest of
the list.  Typically in Perl we might use a condition like C<if> to code these
two cases.  But in both Functional and Object Oriented programming, it's often
much more elegant to use pattern matching (of which "multiple dispatch" is a
variant.)  C<Moose> provides a rather nice and flexible way of declaring these,
and we'll take advantage of it.

    use MooseX::MultiMethods;

    # can be called as a class method
    multi method fromArray ($self:) {
        return List::Empty->new;
    }
    multi method fromArray ($self: $head, @tail) {
        tail_call List::Link->new(
            head => $head,
            tail => $self->fromArray(@tail),
        );
    }

=head2 Getting data out of a list

While arrays and lists both store collections of data, the representations make
certain tasks easier or more difficult.  Accessing an item positionally, for
example, is trivial with an array:

     0  1  2  3  4 
    [h][e][l][l][o]

    To access item number 3, find the beginning of the array, and get the 
    contents of the box 3 positions to the right.

With a list, on the other hand, we don't have an easy way to jump to another
element, as each cell is stored in a different location in memory.

    [h.]->[e.]->[l.]->[l.]->[o.]->()

Instead we need to visit each cell in turn until we arrive at the right C<head>
element.

Obviously, we can't index into an Empty list:

    multi method nth (List::Empty $self: Int $pos) { 
        die "Can't index into an Empty list"; 
    }

And if we want the zero-th element of a list, then we're just looking for its
head.

    multi method nth (Int $pos where { $_ == 0 }) {
        return $self->head;
    }

But if we've passed a positive integer, then we can simply recurse down the
tail, looking for the C<nth> of the next lowest integer, until we get to 0.

    multi method nth (Int $pos where { $_ > 0 }) {
        return $self->tail->nth( $pos - 1 );
    }

Notice how we've specified all the valid ways to call this method.  If we call C<$list-E<gt>nth("foo")> or
C<$list-E<gt>nth(-1)> then Moose will throw an error for us automatically!

As with the fromArray method, this kind of recursive code is very elegant, but
there is a teensy little problem: dynamic languages were never designed for
this kind of code structure, and that means that, by default, they do have a
few little hiccups that we need to be aware of.

=head2 Tail calls and recursion limits

TODO: move this to after the fromArray method, so it's after the FIRST recursive
definition

In the method C<nth> above, we recurse back into the same method until we reach
the right position.  Every time we do this, we are making a new method call,
which is added to the call stack.  This requires storing information about the
caller, and to support these very dynamic languages, may require quite a
I<lot> of information... And finally, once we get to the base case, and are
ready to return the result, the interpreter will then have to hop back through
the stack, one level at a time, till it gets back to the top, passing the result
information up all the way to the top.

If we make many of these recursive calls, then the interpreter may start to
complain about what we're doing.  For example, in Perl:

    Deep recursion on subroutine "List::nth" at foo.pl line 20

There are ways to eliminate these warnings

    no warnings 'recursion';
    $DB::deep = 100_000_000; # some big number, greater than maximum number of
                             # recursions

But that would only be papering over the synptoms, the root problem would
remain: we may blow all the memory allocated to the call stack, and the
interpreter may crash.

In languages like Scheme and Haskell, which are built around recursive data
structures, the compilers will naturally do Tail Call Elimination. This means
that if the last action in a routine is to call another method (often, but not
always, the current method) then you can simply jump to that method, without
having to add the overhead of storing the call on the stack.

Though Perl can't do this automatically, there are two modules on CPAN by
Yuval Koogman that will allow you to handle this elegantly,
C<Sub::Call::Tail> and C<Sub::Call::Recur>.  The latter is faster, but only
handles function calls that recurse into itself.  The former can handle tail
calls to any subroutine, and also object methods, so we'll use that.

By default, C<Sub::Call::Tail> exports a function called C<tail>... which could
confuse both the reader and C<perl>.  We'll use the ability to import an aliased
function, and call it C<tail_call> instead, which makes it much clearer!

 # the slightly nicer 'use' line is implemented in 
 # https://github.com/osfameron/sub-call-tail release pending ;-)

    # take that, recursion!
    use Sub::Import 'Sub::Call::Tail' tail => { -as => 'tail_call' };
    # use Sub::Call::Tail tail => { -as => 'tail_call'};

    multi method nth (Int $pos where { $_ > 0 }) {
        tail_call $self->tail->nth( $pos - 1 );
    }

There are similar workarounds available for Python, Ruby, and Javascript.  They
will usually use a C<goto> statement in some form, perhaps a structured one
that either jumps back to the beginning of the block.  (The Perl hack is
implemented with a C<goto &function> call, which, though it shares the same
name as the reviled control-flow operation, actually does something slightly
cleaner, simply replacing the currently running subroutine with the new one.)

=head2 Transformations on lists

=head3 Applying a function to a list: C<map>

We often want to apply a function to all elements of a collection.  For
example, we may have a list of user records, and we want a list of full names.

The dynamic languages, for the most part, have already borrowed this
functionality from the world of Functional Programming, and often call it
C<map>.

    my @users = (
        {
            first_name => 'Bob',
            last_name  => 'Smith',
        },
        {
            first_name => 'Aisha',
            last_name  => 'Chaudhury',
        }
    );

    use signatures;
    sub full_name ($user) {
        return join ' ' => 
            $user->{first_name},
            $user->{last_name};
    }

    my @full_names = map full_name($_), @users;

To define map for a linked list, we of course define it recursively!

    multi method map (List::Empty $self: CodeRef $f) { 
        return $self;
    }
    multi method map (List::Link $self: CodeRef $f) {
        tail_call $self->new( 
            head => $f->($self->head),
            tail => $self->tail->map( $f )
        );
    }

and later:

    my $users = List->fromArray(@users);

    my $names = $users->map( \&full_name );

=head4 Functors

Note how we started with a function that operated on a single value:

    full_name :: { first_name, last_name } -> "Full name"

And we've ended with one that operates on whole collections:

    map(full_name) :: [List of {...}] -> [List of "Full name"]

Often, in the world of FP, we'll call this kind of operation a Functor.  You'll
often see the operation that we just defined as C<map> called C<fmap> instead
(i.e. Functor Map).  Converting a function that operates on a single value to
one that operates on a collection (or any other type of container) is called
I<lifting> the function.

=head3 C<filter>

Another key operation on any collection type is to filter them by some criteria.
All the dynamic languages offer this facility for their native types, usually
calling them C<grep> or C<filter>, or in some cases using a more general
facility called List Comprehensions.  We'll implement the simple filter case,
again recursively.

    multi method filter (List::Empty $self: CodeRef $f) { 
        return $self;
    }
    multi method filter (List::Link $self: CodeRef $f) {
        my $head = $self->head;
        if ($f->($head)) {
            tail_call $self->new( 
                head => $head,
                tail => $self->tail->filter( $f ),
            );
        }
        else {
            tail_call $self->tail->filter( $f );
        }
    }

=head3 C<fold>

=head2 Modifying the list (inserting, deleting, editing)

=head2 Compare to a mutable list TODO

Let's compare this with an array:

     0  1  2  3  4 
    [h][e][l][l][o]

The array has 5 slots, stored next to each other in memory.  This means that
we can immediately access any of them in any order.  However, if we want to 
add a new element, we'd have to resize the array.  We'll have a look at this
in more detail later.
