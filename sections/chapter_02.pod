=head0 Lists

=head1 Overview plan

    - Singly-linked lists
        - some characteristics
        - how they are formed
        - basic implementation (in Perl)
    - Indexing into a list
    - Interlude: Tail recursion, TCE
    - List operations
        - map / fmap
        - filter
        - fold
    - Modifying, inserting, deleting list elements
        - mutable versus immutable
        - compare with a mutable Vector (such as Perl's arrays)
    - Copying lists
        - how to deep copy an immutable data-structure ;-)
        - caching Empty (MooseX::Singleton)
        - caching generally (Memoize?)
    - Infinite lists
        - laziness
        - implementation
    - Doubly-linked lists?
        - mutable... immutable?
        - pointers
        - code
        - rewrite with Data::Zipper

    - Exercise: implement a turing machine with a zipper onto an infinite
        (in both directions) list

    - Show me the Code!: implementations of the above concepts
      (or, if available, usages of equivalent, available library functions)
        - Modern Perl with Moose
        - Javascript
        - Ruby
        - Python

=head1 Linked lists

The linked list is one of the oldest data structures in computing, dating
back to the mid-1950s.  While it's a collection type, similar to an Array,
it makes very different tradeoffs.

In a dynamic programming language like Perl, Ruby, Python, or Javascript,
we very rarely feel the need to look beyond the builtin array types, as they
are usually Good Enough.  However, the linked list I<is> a fundamental building
block, and we'll see that it is key for understanding concepts such as:

=over

=item *

recursive thinking

=item *

data-sharing

=item *

persistent data structures

=back

Beyond this, linked lists do have some features that arrays don't

=over

=item *

ability to handle circular data

=item *

infinite lists and streams

=item *

possibility for automatic parallelisation

=back

A linked list is a structure that contains an element (often called the
C<head>) and a pointer to the rest of the list (the C<tail>).

For example, the word C<"hello"> is made up of the list of characters:

    [h.]->[e.]->[l.]->[l.]->[o ]
     ^    ^
   head   tail

The head is the letter C<"h">, and the tail is the list

    [e.]->[l.]->[l.]->[o ]

So we've seen lists of 4 and 5 elements.  You could grow the list arbitrarily
large, by continuing to add links to new elements.  

How about smaller lists?

    1 element:   [o ]
    0 elements:  ()

The 0-element list doesn't have a head or a tail.  It's just an empty list.
But how about the 1-element list?  It has a C<head>, but does it have a
C<tail>?

Well, we saw that the tail of the list C<"hello"> was the list C<"ello">.
So the tail of C<"o"> should be the list C<"">, i.e. the empty list.

This means that really our lists look like:

    [o.]->()

    [h.]->[e.]->[l.]->[l.]->[o.]->()

Which means that all lists have a head I<and> a tail. Unless they're the empty
list, which has neither.  i.e. a list can be one of two things:

    ()      the empty list
    [x.]->  a linking cell the connects a value to another list
            (where the other list is either another linking cell
            or an empty list)

L<implementation_note>

=head1 Implementation

Let's have a look now at how we could represent this in code.  As usual,
we'll look at examples in Modern Perl.  We'll add code and explanations in
Ruby, Python, and JavaScript at the end of the chapter.

We I<could> represent the two cases as

    []              an empty array
    [$head, $tail]  an array representing a tuple of head and tail

However, in this book we'll use objects declared using C<Moose> wherever we
can.  This will give more straight-forward code, as well as having a lot of
power that we'll need when we go on to more complex scenarios.

Note that all of the code examples are implemented and tested at 
C<https://github.com/osfameron/pure-fp-book/tree/master/code>, so you can
easily check how things hang together. If there's no implementation in your
language, then please fork the code on github and contribute!

As we saw, there are two types of list.  From an Object Oriented perspective,
we might think of implementing this with an Abstract Base Class (i.e. one that
only acts as a superclass, to tie together related functionality and type
information, but which can't be instantiated into a C<-E<gt>new> object; and
then with concrete subclasses.  The Moosey way to do this is to use a C<Role>
(also known as a trait, and similar in many ways to Ruby's mixins).

    use MooseX::Declare;
    BEGIN { role_type 'List' }

    role List {
        requires 'head';
        requires 'tail';
    }

    class List::Link with List {
        has head => ( is => 'ro', isa => 'Any' );
        has tail => ( is => 'ro', isa => 'List' ),
    }

    class List::Empty with List {
        method head { die "Can't take head of empty list!" }
        method tail { die "Can't take tail of empty list!" }
    }

With this code, we could already create a list, but it'd be a little verbose:

    my $list = List::Link->new(
        head => 'h',
        tail => List::Link->new(
            head => 'e',
            tail => List::Link->new(...

So let's add a little sugar.  We'll create a function C<fromArray> that we'll
call like so:

    my $list = List->fromArray( 1..10 );

As lists are a recursive data structure, it makes sense to implement this in
a recursive way so:

=over

=item * 

If the array is empty, we return an empty list.  

=item * 

If the array has one element, we'll link that with the empty list

=item * 

... and, in general, we'll link the first element in the array with the result
of calling C<fromArray> on the remainder of the array.

=back

Typically in Perl we might use a condition like C<if> to distinguish between
these cases.  But in both Functional and Object Oriented programming, it's
often much more elegant to use pattern matching (of which an OO "multiple
dispatch" is a variant.)  C<Moose> provides a rather nice and flexible way of
declaring multiply dispatched methods, and we'll take advantage of it.

    use MooseX::MultiMethods;

    # can be called as a class method, or on an object
    multi method fromArray ($class:) {
        return List::Empty->new;
    }
    multi method fromArray ($class: $head, @tail) {
        return List::Link->new(
            head => $head,
            tail => $class->fromArray(@tail),
        );
    }

This kind of recursive code is very elegant.  But there is a teensy little
problem: dynamic languages were never designed for this kind of code structure,
and that means that, by default, they do have a few little hiccups that we need
to be aware of.

=head2 Tail calls and recursion limits

In the method C<fromArray> above, we recurse back into the same method until
we've converted all the elements of the array into a List.  Every time we do
this, we are making a new method call, which is added to the call stack.  This
requires storing information about the caller, and to support these very
dynamic languages, may require quite a I<lot> of information... And finally,
once we get to the base case, and are ready to return the result, the
interpreter will then have to hop back through the stack, one level at a time,
till it gets back to the top, passing the result information up all the way to
the top.

If we make many of these recursive calls, then the interpreter may start to
complain about what we're doing.  For example, in Perl:

    Deep recursion on subroutine "List::fromArray" at foo.pl line 20

There are ways to eliminate these warnings

    no warnings 'recursion';
    $DB::deep = 100_000_000; # some big number, greater than maximum 
                             # number of recursions

But doing so would only be papering over the synptoms, the root problem would
remain: we may blow all the memory allocated to the call stack, and the
interpreter may crash.

In languages like Scheme and Haskell, which are built around recursive data
structures, the compilers will naturally do Tail Call Elimination. This means
that if the last action in a routine is to call another method (often, but not
always, the current method) then you can simply jump to that method, without
having to add the overhead of storing the call on the stack.

Though Perl can't (yet?) do this kind of optimization automatically, there are
two modules on CPAN by Yuval Koogman that will allow you to handle this
elegantly, C<Sub::Call::Tail> and C<Sub::Call::Recur>.  The latter is faster,
but only handles function calls that recurse into themselves.  The former can
handle tail calls to any subroutine, and also object methods, so we'll use
that.

By default, C<Sub::Call::Tail> exports a function called C<tail>.  As our List
class already has a method C<tail> (meaning something quite different), this
could confuse both the reader and C<perl> itself.  So we'll take advantage of
the facility to import an aliased function, and call it C<tail_call> instead,
which makes it much clearer!

 # the slightly nicer 'use' line is implemented in 
 # https://github.com/osfameron/sub-call-tail release pending ;-)

    # take that, recursion!
    use Sub::Import 'Sub::Call::Tail' tail => { -as => 'tail_call' };
    # use Sub::Call::Tail tail => { -as => 'tail_call'};

    multi method fromArray ($self: $head, @tail) {
        tail_call List::Link->new(
            head => $head,
            tail => $self->fromArray(@tail),
        );
    }

There are similar workarounds available for Python, Ruby, and Javascript.  They
will usually use a C<goto> statement in some form, perhaps a structured one
that either jumps back to the beginning of the block.  

(Interestingly, though the Perl hack in C<Sub::Call::Tail> is implemented with
a C<goto &function> call, which shares the same name as the reviled
control-flow operation, it's substantially cleaner than you might fear.  This
type of C<goto> simply replaces the currently running subroutine with
a new one, a little like Unix's C<exec> switches to a new process.)

=head2 Getting data out of a list 

=head3 Indexing into the list

While arrays and lists both store collections of data, the representations make
certain tasks easier or more difficult.  Accessing an item positionally, for
example, is trivial with an array:

     0  1  2  3  4 
    [h][e][l][l][o]

    To access item number 3, find the beginning of the array, and get the 
    contents of the box 3 positions to the right.

With a list, on the other hand, we don't have an easy way to jump to another
element, as each cell is stored in a different location in memory.

    [h.]->[e.]->[l.]->[l.]->[o.]->()

Instead we need to visit each cell in turn until we arrive at the right C<head>
element.

Obviously, we can't index into an Empty list:

    multi method nth (List::Empty $self: Int $pos) { 
        die "Can't index into an Empty list"; 
    }

And if we want the zero-th element of a list, then we're just looking for its
head.

    multi method nth (Int $pos where { $_ == 0 }) {
        return $self->head;
    }

But if we've passed a positive integer, then we can simply recurse down the
tail, looking for the C<nth> of the next lowest integer, until we get to 0.

    multi method nth (Int $pos where { $_ > 0 }) {
        tail_call $self->tail->nth( $pos - 1 );
    }

Notice how we've specified all the valid ways to call this method.  If we call
C<$list-E<gt>nth("foo")> or C<$list-E<gt>nth(-1)> then Moose will throw an
error for us automatically!

=head3 Converting back to array

It may sometimes be convenient to flatten our List structure back to a native
array.  We could do this again with recursion.

    multi method toArray_recursive (List::Empty $self:) { 
        return ()
    }
    multi method toArray_recursive (List::Link $self:) {
        return ($self->head, $self->tail->toArray_recursive);
    }

But notice how we don't have a convenient function to make a tail call on. The
C<toArray> method is called, but as I<part> of the expression only.  In general,
there are two ways to handle this: 

=over

=item * 

convert the function into a tail-recursive one, by extracting out the stack

=item * 

convert the function into an iterative one, that manages its own stack

=back

As far as I know, the best general tutorial to these methods using a dynamic
programming language is Mark Jason Dominus's I<Higher Order Perl>.  It's not
freely available online at C<http://hop.perl.plover.com/> to check it out, 
and it's well worth buying, whatever your programming language of choice.

We'll just briefly look at an example of each technique.

=head3 converting the function into a tail-recursive one

We'll need to extract the returned C<@array> and instead pass it onwards within
the tail call.

    multi method toArray_stack (List::Empty $self: @stack) {
        return @stack;
    }
    multi method toArray_stack (List::Link $self: @stack) {
        tail_call $self->tail->toArray_stack(@stack, $self->head);
    }

=head3 converting the function into an iterative one

Here we will entirely eschew the idea of making a recursive function call, and
instead loop through the list using a classic imperative programming statement,
the C<while> loop.  We'll also manage our own stack, as a variable C<@stack>.

    method toArray_iterative () {
        my @stack;
        my $list = $self;
        while ($list->isa('List::Link')) {
            push @stack, $list->head;
            $list = $list->tail;
        }
        return @stack;
    }

=head2 Transformations on lists

Every standard library for manipulating lists should come with a number of basic
transformations, for mapping all the values with a function, filtering them
according to some criteria, or reducing the collection to a single value. We'll
look at each of these in turn.

=head3 Applying a function to a list: C<map>

We often want to apply a function to all elements of a collection.  For
example, we may have a list of user records, and we want a list of full names.

The dynamic languages, for the most part, have already borrowed this
functionality from the world of Functional Programming, and often call it
C<map>.

    my @users = (
        {
            first_name => 'Bob',
            last_name  => 'Smith',
        },
        {
            first_name => 'Aisha',
            last_name  => 'Chaudhury',
        }
    );

    use signatures;
    sub full_name ($user) {
        return join ' ' => 
            $user->{first_name},
            $user->{last_name};
    }

    my @full_names = map full_name($_), @users;

To define map for a linked list, we of course define it recursively!

    multi method map (List::Empty $self: CodeRef $f) { 
        return $self;
    }
    multi method map (List::Link $self: CodeRef $f) {
        tail_call $self->new( 
            head => $f->($self->head),
            tail => $self->tail->map( $f )
        );
    }

and later:

    my $users = List->fromArray(@users);

    my $names = $users->map( \&full_name );

=head4 Functors

Note how we started with a function that operated on a single value:

    full_name :: { first_name, last_name } -> "Full name"

And we've ended with one that operates on whole collections:

    map(full_name) :: [List of {...}] -> [List of "Full name"]

Often, in the world of FP, we'll call this kind of operation a Functor.  You'll
often see the operation that we just defined as C<map> called C<fmap> instead
(i.e. Functor Map).  Converting a function that operates on a single value to
one that operates on a collection (or any other type of container) is called
I<lifting> the function.

=head3 C<filter>ing the list

Another key operation on any collection type is to filter them by some criteria.
All the dynamic languages offer this facility for their native types, usually
calling them C<grep> or C<filter>, or in some cases using a more general
facility called List Comprehensions.  We'll implement the simple filter case,
again recursively.

    multi method filter (List::Empty $self: CodeRef $f) { 
        return $self;
    }
    multi method filter (List::Link $self: CodeRef $f) {
        my $head = $self->head;
        if ($f->($head)) {
            tail_call $self->new( 
                head => $head,
                tail => $self->tail->filter( $f ),
            );
        }
        else {
            tail_call $self->tail->filter( $f );
        }
    }

So, we could now write

    # TODO TEST
    use signatures;
    my $odd_numbers = List->fromArray(1..100)->filter(
        sub ($n) { $n % 2 }
    );

=head3 Reducing a list with C<fold>

Folds are the result of repeatedly applying an operation to every pair of
values in a List until you get a single value.  An example could be finding the
sum of a list of numbers.

    sum (1,2,3,4,5) = 1 + 2 + 3 + 4 + 5

We could think of the sum as:

    1 + (2 + (3 + (4 + 5))) <-- a right fold

or as

    (((1 + 2) + 3) + 4) + 5 <-- a left fold

Oddly, these two folds, C<foldRight> and C<foldLeft> have rather different
characteristics: sometimes one will be faster, or will never complete.

With all these recursive algorithms, we have to consider the "base case",
which for lists means "what happens with an empty list?"  The typical way
to do this is to also include a parameter which is an I<identity> value.
For a C<sum> operation, this would be C<0>.

    sub add ($x,$y) { $x + $y },
    sub sum ($nums) {
        return $nums->fold( \&add, 0 );
    }

Whereas for a multiplicative C<product> it would be C<1>

    sub multiply ($x,$y) { $x * $y },
    sub product ($nums) {
        return $nums->fold( \&multiply, 1 );
    }

Though in both these cases, the fold's input and output are the same type of
value, folds allow the result to be a different type entirely.  In general, we
call the result an I<accumulator>, as it accumulates the folder data as we
progress through the list.

Let's have a look at the left-fold first.

    multi method foldLeft (List::Empty $self: CodeRef $f, $acc) {
        return $acc;
    }
    multi method foldLeft (List::Link $self: CodeRef $f, $acc) {
        tail_call $self->tail->foldLeft($f, $f->($self->head, $acc));
    }

So the left fold is a typical recursive function.  Note how we have to pass
the accumulator to the first call - often we'd call this the I<init> argument.

While it's easy to see what the init argument should be, in many cases, you
may have noticed that my original example omitted one:

    sum (1,2,3,4,5) = 1 + 2 + 3 + 4 + 5

In this case we can simply use the first element in the list to start things
off.  Often such a fold is labelled with the number C<1>.  

    # TODO test
    method foldLeft1 (List::Link $self: CodeRef $f, $acc) {
        return $self->tail->foldLeft1($f, $self->head);
    }

As we've specified that C<$self> must be a linking list, the method will fail
entirely on an empty list.  This is entirely expected behaviour for a C<foldLeft1>
or C<foldRight1>.

# TODO case where we have an accumulator, rather than a typical binop

Now let's have a look at a right fold.  The empty case is, of course, the same:

    multi method foldRight (List::Empty $self: CodeRef $f, $acc) {
        return $acc;
    }

But note how, unlike C<foldLeft>, the right fold isn't tail recursive:

    multi method foldRight (List::Link $self: CodeRef $f, $acc) {
        tail_call $f->(
            $self->head,
            $self->tail->foldRight($f, $acc),
        );
    }

Though we have a tail call, it's only on the folding function C<$f>.  The
actual call back into C<foldRight> isn't in the tail position, where it can be
easily optimized, but rather I<inside> the call to this folding function.

=over

=item EXERCISE:

Try to optimize C<foldRight> by making it tail-recursive or iterative, as
we saw above with C<toArray>

=back

Later, when we look at infinite lazy lists, we'll come back to another little
tweak that languages like Haskell use to optimize right folds.

=head2 Modifying the list

We noted earlier that an array was represented as a contiguous area of memory
while a list is a series of nodes that point to each other

    ARRAY:
     0  1  2  3  4 
    [h][e][l][l][o]

    LIST
    0     1     2     3     4     5
    [h.]->[e.]->[l.]->[l.]->[o.]->()

We saw above that the code to access the C<nth> element of a list was rather
more complicated than for an array.  Similarly, other operations are more
(or less) complicated.  We'll look at updating a single element, inserting a
new one, and deletion in turn, comparing the trade-offs between an array and
a list.

=head3 Updating an element

If we want to change our list to C<"hullo"> instead, then this is easy with
an array.

    $array[1] = "u";

    ARRAY is now:
    [h][u][l][l][o]

Of course we've now "lost" the original representation of "hello", because
the contents of that array have been entirely written over.  Now, we might
want to do the same thing with a list

    $list->mutateAt(1, 'u');

    LIST
    0     1     2     3     4     5
    [h.]->[u.]->[l.]->[l.]->[o.]->()
           ^
           changed in-place

And of course we'd do it recursively:
    
    # NOT TESTED
    multi method mutateAt (List::Empty $self: Int $pos, $new) { 
        die "Can't mutate an Empty list"; 
    }
    multi method mutateAt (Int $pos where { $_ == 0 }, $new) {
        $self->head($new);
    }
    multi method mutateAt (Int $pos where { $_ > 0 }, $new) {
        tail_call $self->tail->mutateAt($pos - 1, $new);
    }

However, that would be a I<mutation> of a value, and in this book, we're mostly
interested in I<immutable>, pure data structures.  Note that we even declared
our attributes with read-only (C<'ro'>) accessors.  

    class List::Link with List {
        has head => ( is => 'ro', isa => 'Any' );
        has tail => ( is => 'ro', isa => 'List' ),
    }

If we relax these to C<'rw'>, we could make the C<mutateAt> code work.  This is
how you might typically work with linked lists in a language like C<C>.  But
of course such a list shares the disadvantage of the array mutation - that we
have now lost the original C<"hello"> sequence.  Let's see if we can do better.

So, we want to retain the C<'e'> node, but avoid it, like so:

    LIST
    0     1     2     3     4     5
    [h.]->[e.]->[l.]->[l.]->[o.]->()
        \     /
          [u.]

But of course the node C<'h'> can't point to two tails!  So we could relink it
entirely:

    LIST
    0     1     2     3     4     5
    [h.] x{e.}->[l.]->[l.]->[o.]->()
        \     /
          [u.]

But of course that means I<mutating> the tail of the the list C<'h'>, which
we've promised we wouldn't do... immutable data-structures are I<hard>!

The trick turns out to be to I<copy> everything before the element we're
changing.

    LIST
    0     1     2     3     4     5
    [h.]->[e.]->[l.]->[l.]->[o.]->()
              /
    [h.]->[u.]

We now have I<2> different nodes that both contain the value C<'h'> in their
head, but which are in fact different lists: they have entirely different
tails.  Note, though, that they converge at C<'l'>, so we only need to copy
part of the list.

    # NOT TESTED
    multi method updateAt (List::Empty $self: Int $pos, $new) { 
        die "Can't update an Empty list"; 
    }
    multi method updateAt (Int $pos where { $_ == 0 }, $new) {
        List::Link->new({
            head => $new,
            tail => $self->tail,
        });
    }
    multi method updateAt (Int $pos where { $_ > 0 }, $new) {
        tail_call List::Link->new({
            head => $self->head,
            tail => $self->tail->updateAt($pos - 1, $new);
        });
    }

If you think about it, this method is following the same pattern of C<nth>,
except that instead of just descending the list till we get to the element we
want, we copy the list as we go.  Then, once we get to position C<0>, 
we link this copied part of the list with the updated element, and the rest of
the list.

All this copying may seem inefficient.  If you have to do multiple updates,
then you will end up copying at least the I<beginning> of the list each time.
Tellingly, Haskell's I<Prelude> (the standard library), with a very rich set of
functions to manipulate linked lists.  entirely omits any version of 
C<updateAt>.

In fact, a linked list, by default isn't the optimal structure for random
access.  However, we have seen that the benefit of using an immutable structure
is that we get to keep the old and new versions of a structure at the same
time, and with minimal memory usage, because of the sharing of data between the
two structures.

This technique of data sharing where possible (and cloning with updated values
where not) will be a common tool, so it is worth getting to grips with this
simple example first, so we'll look now at inserting and deleting elements from
a list.

In both these cases, we'll say that the operation is perhaps I<less> convenient
with an array.

=head3 Inserting a new element

We already saw that arrays are contiguous.  We will have reserved a block of
memory for the array, so to insert into it, we first have to copy all of the
data to the right, and finally insert the element.  So, for example, to insert
the missing letter into the alphabet, we'd do:

    ARRAY:
     0  1  2  3 
    [a][b][d][e]

    copy
     0  1  2  3  4
    [a][b][d][d][e]

    update
     0  1  2  3  4 
    [a][b][c][d][e]

That looks nice and straight-forward: but of course the array didn't have this
extra element reserved!  In the dynamic languages what we call an I<array>
is usually in fact a I<dynamic array> or I<vector>, which will resize itself
behind the scenes.  So in the above example, when we try to add a new element
to the vector, our insert algorithm must first realise that we're growing the
array, and then allocate a new block of space (we'll double the storage space
here, to avoid having to re-allocate too often).

    ARRAY:          NEW
     0  1  2  3     0  1  2  3  4  5  6  7
    [a][b][d][e]   [ ][ ][ ][ ][ ][ ][ ][ ]

Then we'll copy the data to the left of the insertion

    ARRAY:          NEW
     0  1  2  3     0  1  2  3  4  5  6  7
    [a][b][d][e]   [a][b][ ][ ][ ][ ][ ][ ]

and to the right

    ARRAY:          NEW
     0  1  2  3     0  1  2  3  4  5  6  7
    [a][b][d][e]   [a][b][ ][d][e][ ][ ][ ]

and of course, add the inserted element.  (Now, finally, we can de-allocate the
old array from memory).

                    NEW
                    0  1  2  3  4  5  6  7
                   [a][b][c][d][e][ ][ ][ ]

As you can see, this is quite a lot of work, and that's the reason why we 
pre-allocated a larger range of memory than needed.  The next time we insert
a value, we can use our first, simpler version, and only need to resize again
once we need more than 8 elements.  Of course, this does mean that we also need to keep track of the number of items in the array:

                    NEW
                    0  1  2  3  4  5  6  7    #count
                   [a][b][c][d][e][ ][ ][ ]    5

Let's look at how we'd insert an element into a list:

    LIST
    0     1     2     3     4
    [a.]->[b.]->[d.]->[e.]->()

We need to re-point the link from C<b> to a new list with value C<c> that
points to the remainder of the list C<d>.

    LIST
    0     1      3     4     5
    [a.]->[b.]   [d.]->[e.]->()
             \   /
             [c.]
             2

If we were using a mutable data-structure, we'd do exactly this, and just
mutate the references to point to the right place.   With a pure, immutable
list, we'll take advantage of sharing as before (by pointing to the C<e> list,
which remains unchanged) but we'll also have to copy the start of the list.

    LIST
    0     1     2     3     4     5
    [a.]->[b.]------->[d.]->[e.]->()
                    /
    [a.]->[b.]->[c.]

The insertion code is quite simple, and follows the same structure as 
C<updateAt>:

    # NOT TESTED
    multi method insertAt (List::Empty $self: Int $pos, $new) { 
        die "Can't insert into an Empty list"; 
    }
    multi method insertAt (Int $pos where { $_ == 0 }, $new) {
        List::Link->new({
            head => $new,
            tail => $self,
        });
    }
    multi method insertAt (Int $pos where { $_ > 0 }, $new) {
        tail_call List::Link->new({
            head => $self->head,
            tail => $self->tail->insertAt($pos - 1, $new);
        });
    }

Just as before, we copy the head of the list up until the point we want to
insert.  In fact, there is only difference between the routines!  Instead of
linking the list to the original position's I<tail>, we link to the whole list.

=head3 Deleting an element

Deletion from an array will always involve shifting the elements after the
one deleted to the left, and then decreasing the element count.

    array
    0  1  2  3  4  5  6  7
   [h][a][l][l][o][ ][ ][ ]  #5

   [h][a][l][o][ ][ ][ ][ ]  #4

At this point, the algorithm might choose to reallocate the memory, to shrink
the size of data stored.

Again, using linked lists, this could be trivial.

    LIST
    0     1     2     3     4     5
    [h.]->[a.]->[l.]->[l.]->[o.]->()

    [h.]->[a.]->[l.]------->[o.]->()

But again, if we want to use immutable lists, we'll have a copy and share,
as before.

    # NOT TESTED
    multi method deleteAt (List::Empty $self: Int $pos) { 
        die "Can't delete from an Empty list"; 
    }
    multi method deleteAt (Int $pos where { $_ == 0 }) {
        return $self->tail;
    }
    multi method deleteAt (Int $pos where { $_ > 0 }) {
        tail_call List::Link->new({
            head => $self->head,
            tail => $self->tail->deleteAt($pos - 1, $new);
        });
    }

This follows the same structure again, except that once we get to the element
we want to delete, we simply skip over its C<head> and return its C<tail>
instead.

=head3 Copying

TODO: a) we "copied" tail of list by just pointing at it.  "copy" of first part
was in fact a change.  But a *deep copy* of a Pure FP structure is as simple
as referring to it.
TODO b) MooseX::Singleton

=head3 Comparing the array and list approaches

The pros and cons of each approach might include:

=over

=item Lists

=over

=item * 

simple implementation for each case

=item * 

immutable data - the old version still exists, if you need it

=item * 

no having to shunt the right hand side of the list around in memory

=item * 

no having to reallocate and move the entire structure as it grows and
shrinks

=back

=item Array

=over

=item * 

Very fast for updating single elements in place

=item * 

No having to copy the left-hand side of the array each time

=item * 

The result will still be an array - this may be important if you will
be doing a lot of random access into the array.

=back

=back

It is important to be aware of these trade-offs when deciding whether to look
beyond your language's default dynamic array type, or not.

But of course, so far we've only seen lists that are linked in one direction
(also known as "singly linked lists".)  To be able to fairly compare lists to
arrays, we'll now look at at a variant that can be used to traverse the list
in both directions.

Later in the book, we'll also look at Trees, which may further address concerns
with efficient random access to given elements.

=head2 Doubly linked lists

We've seen that it's easy to traverse our linked lists from the beginning, by
following the tail until we get to the C<empty> list at the end.  This is a
fundamental capability, and is used by many fundamental functions, for example
C<map>, C<filter>, and C<fold>, as we saw.  Occasionally, though, we will want
to be able to traverse a list in I<both> directions.

For example, consider a list of tabs in a web browser:

              google.com
              google.com search results
   focused -> guardian.co.uk             
              hop.perl.plover.com/book
  
We might want to move to the next tab to the right (the I<Higher Order Perl>
book) or to the left (Google search results).

A classic structure from computer science is the I<doubly linked> list: as
the name implies, rather than having just a C<head> and a C<tail>, it will
have instead a C<value> and then two links to C<prev> and C<next>

So, the tabs I showed above might be represented as:

   ()<-[.1.]<->[.2.]<->[.3.]<->[.4.]->()

In a mutable programming language, we might iterate each node, pointing it to
the C<next> node, and then pointing the next node's C<prev> back at it.

Of course we can't, strictly speaking, do that in a pure style.  But we have
at least two options:

=over

=item 1.  B<Cheat!>

Though we're looking at purely functional data-structures, the fact remains
that Perl, Python, Ruby, Javascript and friends are not purely functional
languages.  We I<can> mutate values, when we need to, and nothing prevents
us from writing:

  method fromArray ($class: @array) {
    # ... hackety hack ...
    return $self
  }

Of course, if we'd declared C<next> and C<prev> as C<'ro'> accessors, then
C<Moose> would prevent us from setting these.  Again, nothing prevents us
from simply declaring the accessor as C<'rw'> (except the fear of shooting
ourselves in the feet later!)  We could alternatively retain the readonly
accessor, but set the value directly by either access to the underlying hash
or (slightly more cleanly, but more verbosely) by calling methods on Moose's
I<meta-object protocol>.

All of these would be hacks, I<but> they would be well encapsulated hacks,
i.e. happen only during the list construction, and we'd be entirely pure
for the object's actual lifetime.

EXERCISE: I'll leave creating a list by cheating as an exercise to the
interested reader.

=item 2.  B<Use laziness>

If we're being pure we can't I<go back> and set the C<next> field to the new
object once we've constructed it.  So, one solution would be to set the
C<next> to the value I<before> we've constructed it!

If you've not programmed with laziness before, the last paragraph might sound
simply insane.  How could you possibly use a value before it's built?  Yet
languages like Haskell use this throughout.  Though it's technically quite
challenging to retrofit laziness to a language not designed for it, there are
several modules for Perl that attempt to do this.  We'll look at C<Data::Thunk>.

    my $x = lazy { say "Boo!"; 4 };
    # Right now, $x is a "promise" which will later by evaluated as 4.

    my $y = $x + 1;
    # Boo!
    # $x is now replaced with <4>.  $y is now <5>

Amazingly, this also works for less trivial examples, so let's try to use it
to create a doubly linked list.  First of all, here's our class:

    use MooseX::Declare;
    use Moose::Util::TypeConstraints;

    BEGIN { role_type 'DLL' };
    role DLL { }

    class DLL::Empty with DLL { }
    class DLL::Node with DLL {
        has val  => ( isa => 'Any', is => 'ro' );
        has prev => ( isa => 'DLL', is => 'ro' );
        has next => ( isa => 'DLL', is => 'ro' );
    }

We'll also define some helper functions:

    use syntax 'function';
    fun empty {
        DLL::Empty->new
    }
    fun node ($val,$prev,$next) {
       DLL::Node->new(val=>$val, prev=>$prev, next=>$next);
    }

And now we can create our list.  Note that we do it all in a C<do> statement,
which introduces a new lexical scope: this is vital for creating this kind
of circular reference.  Note that we have to declare the variables before we
assign them, which we wouldn't have to do in Haskell, in order to appease the
Perl compiler.

    my $list = do {
        my ($x, $y, $z);
        $x = lazy { node 1, empty, $y };
        $y = lazy { node 2, $x,    $z };
        $z = lazy { node 3, $y, empty };
        $x;
    };

This doesn't quite work: it turns out that our C<thunk> can't quite fool
Moose's type-checker into standing for it lazily.  But if we change those
declarations to:

        has prev => ( isa => 'Any', is => 'ro' );
        has next => ( isa => 'Any', is => 'ro' );

This actually works!

    say $list->next->next->prev->val;   # 2!

This technique is known in Haskell circles as "Tying the knot", and is
fascinating, and somewhat magical.

Of course, manually having to construct the list as we did there is fiddly
and repetitive so...

EXERCISE: define the method C<fromArray> using laziness, for any number of
elements.

=back

You'll have noticed that I've left implementing both the workarounds as
exercises.  Though they're no doubt interesting, and valuable learning projects,
it turns out that doubly linked lists may be suboptimal in a purely functional
context, and we'll shortly look at a better alternative.

=head3 Modifying a doubly linked list
Z<modifying_a_doubly_linked_list>

Let's look at what happens when you modify an element in a doubly linked
list:

   ()<-[.1.]<->[.2.]<->[.3.]<->[.4.]->()
                     ?\     /?
                       [.5.]

As we saw before, with singly linked lists, we'd have to copy the left hand
side of the list, because the list is flowing I<in the direction of> a changed
value, and is therefore itself changed.

   ()<-[.1.]<->[.2.]<->[.3.]<->[.4.]->()
                            /?
   ()<-[.1.]<->[.2.]<->[.5.]

So that means going through the fiddly 2-way linking process on the whole of
the left side.  But notice that I highlighted the phrase "in the direction of",
but we're looking at a list that flows in I<both> directions.  This means we
also need to copy the right hand side!

   ()<-[.1.]<->[.2.]<->[.3.]<->[.4.]->()
                              
   ()<-[.1.]<->[.2.]<->[.5.]<->[.4.]->()

So any change to a doubly linked list requires modifying the whole list!  This
makes them a poor choice for purely functional programming, at least in the case
where you have to make any changes after construction.

=head3 Garbage collection

In Perl, memory is allocated using I<reference counting>.  Every time a value is
referred to by something (a variable, or an object attribute) this is added to
its reference count.  When a reference is dropped, this is reduced.  When the
count reaches C<0>, the object is garbage collected.

Now, for simple cases, this works perfectly.  With a singly linked list, for
example:

                
    my $list = List->fromArray(1,2,3)
    
                    [1.]->[2.]->[3.]->()
    referred to:    $list <1>   <2>  <3>
    from   
    count:           1    1     1     1

The first item C<1> has a single reference (from C<$list>) and the subsequent
references via C<tail> keep the rest of the list in memory.  If we now move
down into the list, replacing the contents of C<$list> with its own tail:

    $list = $list->tail;

                    [1.]->[2.]->[3.]->()
    referred to:        $list   <2>  <3>
    from   
    count:           0    1     1     1

we can see that Perl is now ready to garbage collect the node C<1>.  Similarly, if we
delete C<$list> entirely, then:

    undef $list;
                    [1.]->[2.]->[3.]->()
    referred to:          X     <2>  <3>
    from   
    count:           0    0     1     1

List no longer has a pointer to C<2>, so in fact this should be:

                    [1.]->[2.]->[3.]->()
    referred to:                X    <3>
    from   
    count:           0    0     0     1

                    [1.]->[2.]->[3.]->()
    referred to:                      X 
    from   
    count:           0    0     0     0

So, for linear structures, this works really well!  But let's look at a circular
structure, for example, a doubly linked list of 2 elements.

                    ()  <-    [.1.]   <->   [.2.]   ->   ()
    referred to:              $list         
    from           1.prev     2.prev        1.next     2.next
    count:           1          2             1           1

Obviously, we I<want>  the list to remain in memory if we move (after all, there's
no value in a list that you can traverse in both directions if the direction you
came from disappears when you move!)

    $list = $list->next;

                    ()  <-    [.1.]   <->   [.2.]   ->   ()
    referred to:                             $list
    from           1.prev     2.prev        1.next     2.next
    count:           1          1             2           1

But if we delete C<$list>, just look what happens.

    undef $list;

                    ()  <-    [.1.]   <->   [.2.]   ->   ()
    referred to:                             
    from           1.prev     2.prev        1.next     2.next
    count:           1          1             1           1

Though there are no variables pointing to any of these values, they will never
get garbage collected!  If your program runs long enough, this kind of space
leak may eventually become a problem.  

Perl has two workarounds for this:

=over

=item *

1. Add a C<DESTROY> method (or, for Moose objects, C<DEMOLISH>) that deletes the
onward reference.  Again, this would require some hacking to delete the
reference behind the scenes, but would be acceptable as it's encapsulated as
part of object destruction.

Of course, in the case of doubly linked lists, the problem is that the object
never gets destroyed, so this isn't relevant.

=item *

2.  Using I<weak references>.  C<Moose> has support for this, by declaring an
attribute with C<weak_ref =E<gt> 1>.  This is great for situations where you
have a I<primary> object which points to other objects, keeping them alive.
They in turn would refer, I<weakly> to their parent object, but wouldn't keep
it alive.  

Unfortunately, a doubly-linked list is exactly the opposite of this:
the list can be focused on any given node, and must keep all the nodes in
either direction alive at all times.  

=back

Effectively, this means that you can't rely on automatic garbage collection for
a doubly linked list, and would have to manually call a C<$list-E<gt>delete>
method (which then unpicks the references all the way along the list in both
directions).

# TODO handwave, further contributions welcome from language experts!
Ruby (at least the MRI implementation) and most modern Javascript
implementations use I<mark-and-sweep> GC instead.  This doesn't suffer the same
problem.  Python uses a slightly modified reference counting algorithm with
cycle detection, so may also avoid the issue.

=head3 So...

OK, so the Garbage Collection issue is avoidable, or not an issue, depending on
your language.  But even if you don't program in Perl, it's interesting to look
at the reference counting problem, because it so closely mirrors the issue with
updating a list.  In general, cycles will interfere with the sharing aspect of
functional data structures and, though they may sometimes be necessary or
useful, we'll more often find ways to avoid them.

We'll now look at exactly such a way of traversing a list, while being able to
get back to the beginning.

NEXT: Zippers
