<html>
<body>
<link rel='stylesheet' href='style.css' type='text/css'>

<h1>Lists</h1>

<h2>Overview plan</h2>

<pre><code>    - Singly-linked lists
        - some characteristics
        - how they are formed
        - basic implementation (in Perl)
    - Indexing into a list
    - Interlude: Tail recursion, TCE
    - List operations
        - map / fmap
        - filter
        - fold
    - Modifying, inserting, deleting list elements
        - mutable versus immutable
        - compare with a mutable Vector (such as Perl&#39;s arrays)
    - Copying lists
        - how to deep copy an immutable data-structure ;-)
        - caching Empty (MooseX::Singleton)
        - caching generally (Memoize?)
    - Infinite lists
        - laziness
        - implementation
    - Doubly-linked lists?
        - mutable... immutable?
        - pointers
        - code
        - rewrite with Data::Zipper

    - Exercise: implement a turing machine with a zipper onto an infinite
        (in both directions) list

    - Show me the Code!: implementations of the above concepts
      (or, if available, usages of equivalent, available library functions)
        - Modern Perl with Moose
        - Javascript
        - Ruby
        - Python</code></pre>

<h2>Linked lists</h2>

<p>The linked list is one of the oldest data structures in computing, dating back to the mid-1950s. While it's a collection type, similar to an Array, it makes very different tradeoffs.</p>

<p>In a dynamic programming language like Perl, Ruby, Python, of Javascript, we very rarely feel the need to look beyond the builtin array types, as they are usually Good Enough. However, the linked list <i>is</i> a fundamental building block, and we'll see that it is key for understanding concepts such as:</p>

<ul>

<li>recursive thinking

<li>data-sharing

<li>persistent data structures

</ul>

<p>Beyond this, linked lists do have some features that arrays don't</p>

<ul>

<li>handling circular data

<li>infinite lists and streams

<li>possibility for automatic parallelisation

</ul>

<p>A linked list is a structure that contains an element (often called the <code>head</code>) and a pointer to the rest of the list (the <code>tail</code>).</p>

<p>For example, the word <code>"hello"</code> is made up of the list of characters:</p>

<pre><code>    [h.]-&gt;[e.]-&gt;[l.]-&gt;[l.]-&gt;[o ]
     ^    ^
   head   tail</code></pre>

<p>The head is the letter <code>"h"</code>, and the tail is the list</p>

<pre><code>    [e.]-&gt;[l.]-&gt;[l.]-&gt;[o ]</code></pre>

<p>So we've seen lists of 4 and 5 elements. You could grow the list arbitrarily large, by continuing to add links to new elements.</p>

<p>How about smaller lists?</p>

<pre><code>    1 element:   [o ]
    0 elements:  ()</code></pre>

<p>The 0-element list doesn't have a head or a tail. It's just an empty list. But how about the 1-element list? It has a <code>head</code>, but does it have a <code>tail</code>?</p>

<p>Well, we saw that the tail of the list <code>"hello"</code> was the list <code>"ello"</code>. So the tail of <code>"o"</code> should be the list <code>""</code>, i.e. the empty list.</p>

<p>This means that really our lists look like:</p>

<pre><code>    [o.]-&gt;()

    [h.]-&gt;[e.]-&gt;[l.]-&gt;[l.]-&gt;[o.]-&gt;()</code></pre>

<p>Which means that all lists have a head <i>and</i> a tail. Unless they're the empty list, which has neither. i.e. a list can be one of two things:</p>

<pre><code>    ()      the empty list
    [x.]-&gt;  a linking cell the connects a value to another list
            (where the other list is either another linking cell
            or an empty list)</code></pre>

<h2>Implementation</h2>

<p>Let's have a look now at how we could represent this in code. As usual, we'll look at examples in Modern Perl. We'll add code and explanations in Ruby, Python, and JavaScript at the end of the chapter.</p>

<p>We <i>could</i> represent the two cases as</p>

<pre><code>    []              an empty array
    [$head, $tail]  an array representing a tuple of head and tail</code></pre>

<p>However, in this book we'll use objects declared using <code>Moose</code> wherever we can. This will give more straight-forward code, as well as having a lot of power that we'll need when we go on to more complex scenarios.</p>

<p>Note that all of the code examples are implemented and tested at <code>https://github.com/osfameron/pure-fp-book/tree/master/code</code>, so you can easily check how things hang together. If there's no implementation in your language, then please fork the code on github and contribute!</p>

<p>As we saw, there are two types of list. From an Object Oriented perspective, we might think of implementing this with an Abstract Base Class (i.e. one that only acts as a superclass, to tie together related functionality and type information, but which can't be instantiated into a <code>-&gt;new</code> object; and then with concrete subclasses. The Moosey way to do this is to use a <code>Role</code> (also known as a trait, and similar in many ways to Ruby's mixins).</p>

<pre><code>    use MooseX::Declare;
    BEGIN { role_type &#39;List&#39; }

    role List {
        requires &#39;head&#39;;
        requires &#39;tail&#39;;
    }

    class List::Link with List {
        has head =&gt; ( is =&gt; &#39;ro&#39;, isa =&gt; &#39;Any&#39; );
        has tail =&gt; ( is =&gt; &#39;ro&#39;, isa =&gt; &#39;List&#39; ),
    }

    class List::Empty with List {
        method head { die &quot;Can&#39;t take head of empty list!&quot; }
        method tail { die &quot;Can&#39;t take tail of empty list!&quot; }
    }</code></pre>

<p>With this code, we could already create a list, but it'd be a little verbose:</p>

<pre><code>    my $list = List::Link-&gt;new(
        head =&gt; &#39;h&#39;,
        tail =&gt; List::Link-&gt;new(
            head =&gt; &#39;e&#39;,
            tail =&gt; List::Link-&gt;new(...</code></pre>

<p>So let's add a little sugar. We'll create a function <code>fromArray</code> that we'll call like so:</p>

<pre><code>    my $list = List-&gt;fromArray( 1..10 );</code></pre>

<p>As lists are a recursive data structure, it makes sense to implement this in a recursive way so:</p>

<ul>

<li>If the array is empty, we return an empty list.</li>

<li>If the array has one element, we'll link that with the empty list</li>

<li>... and, in general, we'll link the first element in the array with the result of calling <code>fromArray</code> on the remainder of the array.</li>

</ul>

<p>Typically in Perl we might use a condition like <code>if</code> to distinguish between these cases. But in both Functional and Object Oriented programming, it's often much more elegant to use pattern matching (of which "multiple dispatch" is a variant.) <code>Moose</code> provides a rather nice and flexible way of declaring these, and we'll take advantage of it.</p>

<pre><code>    use MooseX::MultiMethods;

    # can be called as a class method, or on an object
    multi method fromArray ($class:) {
        return List::Empty-&gt;new;
    }
    multi method fromArray ($class: $head, @tail) {
        return List::Link-&gt;new(
            head =&gt; $head,
            tail =&gt; $class-&gt;fromArray(@tail),
        );
    }</code></pre>

<p>This kind of recursive code is very elegant. But there is a teensy little problem: dynamic languages were never designed for this kind of code structure, and that means that, by default, they do have a few little hiccups that we need to be aware of.</p>

<h3>Tail calls and recursion limits</h3>

<p>In the method <code>fromArray</code> above, we recurse back into the same method until we've converted all the elements of the array into a List. Every time we do this, we are making a new method call, which is added to the call stack. This requires storing information about the caller, and to support these very dynamic languages, may require quite a <i>lot</i> of information... And finally, once we get to the base case, and are ready to return the result, the interpreter will then have to hop back through the stack, one level at a time, till it gets back to the top, passing the result information up all the way to the top.</p>

<p>If we make many of these recursive calls, then the interpreter may start to complain about what we're doing. For example, in Perl:</p>

<pre><code>    Deep recursion on subroutine &quot;List::fromArray&quot; at foo.pl line 20</code></pre>

<p>There are ways to eliminate these warnings</p>

<pre><code>    no warnings &#39;recursion&#39;;
    $DB::deep = 100_000_000; # some big number, greater than maximum number of
                             # recursions</code></pre>

<p>But that would only be papering over the synptoms, the root problem would remain: we may blow all the memory allocated to the call stack, and the interpreter may crash.</p>

<p>In languages like Scheme and Haskell, which are built around recursive data structures, the compilers will naturally do Tail Call Elimination. This means that if the last action in a routine is to call another method (often, but not always, the current method) then you can simply jump to that method, without having to add the overhead of storing the call on the stack.</p>

<p>Though Perl can't (yet?) do this kind of optimization automatically, there are two modules on CPAN by Yuval Koogman that will allow you to handle this elegantly, <code>Sub::Call::Tail</code> and <code>Sub::Call::Recur</code>. The latter is faster, but only handles function calls that recurse into themselves. The former can handle tail calls to any subroutine, and also object methods, so we'll use that.</p>

<p>By default, <code>Sub::Call::Tail</code> exports a function called <code>tail</code>. As our List class already has a method <code>tail</code> (meaning something quite different), this could confuse both the reader and <code>perl</code> itself. So we'll take advantage of the facility to import an aliased function, and call it <code>tail_call</code> instead, which makes it much clearer!</p>

<pre><code> # the slightly nicer &#39;use&#39; line is implemented in 
 # https://github.com/osfameron/sub-call-tail release pending ;-)

    # take that, recursion!
    use Sub::Import &#39;Sub::Call::Tail&#39; tail =&gt; { -as =&gt; &#39;tail_call&#39; };
    # use Sub::Call::Tail tail =&gt; { -as =&gt; &#39;tail_call&#39;};

    multi method fromArray ($self: $head, @tail) {
        tail_call List::Link-&gt;new(
            head =&gt; $head,
            tail =&gt; $self-&gt;fromArray(@tail),
        );
    }</code></pre>

<p>There are similar workarounds available for Python, Ruby, and Javascript. They will usually use a <code>goto</code> statement in some form, perhaps a structured one that either jumps back to the beginning of the block.</p>

<p>(Interestingly, though the Perl hack in <code>Sub::Call::Tail</code> is implemented with a <code>goto &function</code> call, which shares the same name as the reviled control-flow operation, it's substantially cleaner than you might fear. This type of <code>goto</code> simply replaces the currently running subroutine with a new one, a little like Unix's <code>exec</code> switches to a new process.)</p>

<h3>Getting data out of a list</h3>

<h4>Indexing into the list</h4>

<p>While arrays and lists both store collections of data, the representations make certain tasks easier or more difficult. Accessing an item positionally, for example, is trivial with an array:</p>

<pre><code>     0  1  2  3  4 
    [h][e][l][l][o]

    To access item number 3, find the beginning of the array, and get the 
    contents of the box 3 positions to the right.</code></pre>

<p>With a list, on the other hand, we don't have an easy way to jump to another element, as each cell is stored in a different location in memory.</p>

<pre><code>    [h.]-&gt;[e.]-&gt;[l.]-&gt;[l.]-&gt;[o.]-&gt;()</code></pre>

<p>Instead we need to visit each cell in turn until we arrive at the right <code>head</code> element.</p>

<p>Obviously, we can't index into an Empty list:</p>

<pre><code>    multi method nth (List::Empty $self: Int $pos) { 
        die &quot;Can&#39;t index into an Empty list&quot;; 
    }</code></pre>

<p>And if we want the zero-th element of a list, then we're just looking for its head.</p>

<pre><code>    multi method nth (Int $pos where { $_ == 0 }) {
        return $self-&gt;head;
    }</code></pre>

<p>But if we've passed a positive integer, then we can simply recurse down the tail, looking for the <code>nth</code> of the next lowest integer, until we get to 0.</p>

<pre><code>    multi method nth (Int $pos where { $_ &gt; 0 }) {
        tail_call $self-&gt;tail-&gt;nth( $pos - 1 );
    }</code></pre>

<p>Notice how we've specified all the valid ways to call this method. If we call <code>$list-&gt;nth("foo")</code> or <code>$list-&gt;nth(-1)</code> then Moose will throw an error for us automatically!</p>

<h4>Converting back to array</h4>

<p>It may sometimes be convenient to flatten our List structure back to a native array. We could do this again with recursion.</p>

<pre><code>    multi method toArray_recursive (List::Empty $self:) { 
        return ()
    }
    multi method toArray_recursive (List::Link $self:) {
        return ($self-&gt;head, $self-&gt;tail-&gt;toArray_recursive);
    }</code></pre>

<p>But notice how we don't have a convenient function to make a tail call on. The <code>toArray</code> method is called, but as <i>part</i> of the expression only. In general, there are two ways to handle this:</p>

<ul>

<li>convert the function into a tail-recursive one, by extracting out the stack</li>

<li>convert the function into an iterative one, that manages its own stack</li>

</ul>

<p>The best general tutorial to these methods using a dynamic programming language may well be Mark Jason Dominus's <i>Higher Order Perl</i>, now freely available online at http://hop.perl.plover.com/ (though it's worth buying, whatever your programming language of choice).</p>

<p>We'll just briefly look at an example of each technique.</p>

<h4>converting the function into a tail-recursive one</h4>

<p>We'll need to extract the returned <code>@array</code> and instead pass it onwards within the tail call.</p>

<pre><code>    multi method toArray_stack (List::Empty $self: @stack) {
        return @stack;
    }
    multi method toArray_stack (List::Link $self: @stack) {
        tail_call $self-&gt;tail-&gt;toArray_stack(@stack, $self-&gt;head);
    }</code></pre>

<h4>converting the function into an iterative one</h4>

<p>Here we will entirely eschew the idea of making a recursive function call, and instead loop through the list using a classic imperative programming statement, the <code>while</code> loop. We'll also manage our own stack, as a variable <code>@stack</code>.</p>

<pre><code>    method toArray_iterative () {
        my @stack;
        my $list = $self;
        while ($list-&gt;isa(&#39;List::Link&#39;)) {
            push @stack, $list-&gt;head;
            $list = $list-&gt;tail;
        }
        return @stack;
    }</code></pre>

<h3>Transformations on lists</h3>

<p>Every standard library for manipulating lists should come with a number of basic transformations, for mapping all the values with a function, filtering them according to some criteria, or reducing the collection to a single value. We'll look at each of these in turn.</p>

<h4>Applying a function to a list: <code>map</code></h4>

<p>We often want to apply a function to all elements of a collection. For example, we may have a list of user records, and we want a list of full names.</p>

<p>The dynamic languages, for the most part, have already borrowed this functionality from the world of Functional Programming, and often call it <code>map</code>.</p>

<pre><code>    my @users = (
        {
            first_name =&gt; &#39;Bob&#39;,
            last_name  =&gt; &#39;Smith&#39;,
        },
        {
            first_name =&gt; &#39;Aisha&#39;,
            last_name  =&gt; &#39;Chaudhury&#39;,
        }
    );

    use signatures;
    sub full_name ($user) {
        return join &#39; &#39; =&gt; 
            $user-&gt;{first_name},
            $user-&gt;{last_name};
    }

    my @full_names = map full_name($_), @users;</code></pre>

<p>To define map for a linked list, we of course define it recursively!</p>

<pre><code>    multi method map (List::Empty $self: CodeRef $f) { 
        return $self;
    }
    multi method map (List::Link $self: CodeRef $f) {
        tail_call $self-&gt;new( 
            head =&gt; $f-&gt;($self-&gt;head),
            tail =&gt; $self-&gt;tail-&gt;map( $f )
        );
    }</code></pre>

<p>and later:</p>

<pre><code>    my $users = List-&gt;fromArray(@users);

    my $names = $users-&gt;map( \&amp;full_name );</code></pre>

<h5>Functors</h5>

<p>Note how we started with a function that operated on a single value:</p>

<pre><code>    full_name :: { first_name, last_name } -&gt; &quot;Full name&quot;</code></pre>

<p>And we've ended with one that operates on whole collections:</p>

<pre><code>    map(full_name) :: [List of {...}] -&gt; [List of &quot;Full name&quot;]</code></pre>

<p>Often, in the world of FP, we'll call this kind of operation a Functor. You'll often see the operation that we just defined as <code>map</code> called <code>fmap</code> instead (i.e. Functor Map). Converting a function that operates on a single value to one that operates on a collection (or any other type of container) is called <i>lifting</i> the function.</p>

<h4><code>filter</code>ing the list</h4>

<p>Another key operation on any collection type is to filter them by some criteria. All the dynamic languages offer this facility for their native types, usually calling them <code>grep</code> or <code>filter</code>, or in some cases using a more general facility called List Comprehensions. We'll implement the simple filter case, again recursively.</p>

<pre><code>    multi method filter (List::Empty $self: CodeRef $f) { 
        return $self;
    }
    multi method filter (List::Link $self: CodeRef $f) {
        my $head = $self-&gt;head;
        if ($f-&gt;($head)) {
            tail_call $self-&gt;new( 
                head =&gt; $head,
                tail =&gt; $self-&gt;tail-&gt;filter( $f ),
            );
        }
        else {
            tail_call $self-&gt;tail-&gt;filter( $f );
        }
    }</code></pre>

<p>So, we could now write</p>

<pre><code>    # TODO TEST
    use signatures;
    my $odd_numbers = List-&gt;fromArray(1..100)-&gt;filter(
        sub ($n) { $n % 2 }
    );</code></pre>

<h4><code>fold</code></h4>

<p>Folds are the result of repeatedly applying an operation to every pair of values in a List until you get a single value. An example could be finding the sum of a list of numbers.</p>

<pre><code>    sum (1,2,3,4,5) = 1 + 2 + 3 + 4 + 5</code></pre>

<p>We could think of the sum as:</p>

<pre><code>    1 + (2 + (3 + (4 + 5))) &lt;-- a right fold</code></pre>

<p>or as</p>

<pre><code>    (((1 + 2) + 3) + 4) + 5 &lt;-- a left fold</code></pre>

<p>Oddly, these two folds, <code>foldr</code> and <code>foldl</code> have rather different characteristics: sometimes one will be faster, or will never complete.</p>

<p>With all these recursive algorithms, we have to consider the "base case", which for lists means "what happens with an empty list?" The typical way to do this is to also include a parameter which is an <i>identity</i> value. For a <code>sum</code> operation, this would be <code>0</code>.</p>

<pre><code>    sub add ($x,$y) { $x + $y },
    sub sum ($nums) {
        return $nums-&gt;fold( \&amp;add, 0 );
    }</code></pre>

<p>Whereas for a multiplicative <code>product</code> it would be <code>1</code></p>

<pre><code>    sub multiply ($x,$y) { $x * $y },
    sub product ($nums) {
        return $nums-&gt;fold( \&amp;multiply, 1 );
    }</code></pre>

<p>Though in both these cases, the fold's input and output are the same type of value, folds allow the result to be a different type entirely. In general, we call the result an <i>accumulator</i>, as it accumulates the folder data as we progress through the list.</p>

<p>Let's have a look at the left-fold first.</p>

<pre><code>    multi method foldl (List::Empty $self: CodeRef $f, $acc) {
        return $acc;
    }
    multi method foldl (List::Link $self: CodeRef $f, $acc) {
        tail_call $self-&gt;tail-&gt;foldl($f, $f-&gt;($self-&gt;head, $acc));
    }</code></pre>

<p>So the left fold is a typical recursive function. Note how we have to pass the accumulator to the first call - often we'd call this the <i>init</i> argument.</p>

<p>While it's easy to see what the init argument should be, in many cases, you may have noticed that my original example omitted one:</p>

<pre><code>    sum (1,2,3,4,5) = 1 + 2 + 3 + 4 + 5</code></pre>

<p>In this case we can simply use the first element in the list to start things off. This obviously wouldn't work for an empty list! Often such a fold is labelled with the number <code>1</code>:</p>

<pre><code>    # TODO test
    method foldl1 (List::Link $self: CodeRef $f, $acc) {
        return $self-&gt;tail-&gt;foldl($f, $self-&gt;head);
    }</code></pre>

<p>As we've specified that <code>$self</code> must be a linking list, the method will fail entirely on an empty list.</p>

<p># TODO case where we have an accumulator, rather than a typical binop</p>

<p>Now let's have a look at a right fold. The empty case is, of course, the same:</p>

<pre><code>    multi method foldr (List::Empty $self: CodeRef $f, $acc) {
        return $acc;
    }</code></pre>

<p>But note how, unlike <code>foldl</code>, the right fold isn't tail recursive:</p>

<pre><code>    multi method foldr (List::Link $self: CodeRef $f, $acc) {
        tail_call $f-&gt;(
            $self-&gt;head,
            $self-&gt;tail-&gt;foldr($f, $acc),
        );
    }</code></pre>

<p>Though we have a tail call, it's only on the folding function <code>$f</code>. The actual call back into <code>foldr</code> isn't in the tail position, where it can be easily optimized, but rather <i>inside</i> the call to this folding function.</p>

<ul>

<li>EXERCISE:</li>

<p>Try to optimize <code>foldr</code> by making it tail-recursive or iterative, as we saw above with <code>toArray</code></p>

</ul>

<p>Later, when we look at infinite lazy lists, we'll come back to another little tweak that languages like Haskell use to optimize right folds.</p>

<h3>Modifying the list (inserting, deleting, editing)</h3>

<h4>Compare to a mutable list TODO</h4>

<p>Let's compare this with an array:</p>

<pre><code>     0  1  2  3  4 
    [h][e][l][l][o]</code></pre>

<p>The array has 5 slots, stored next to each other in memory. This means that we can immediately access any of them in any order. However, if we want to add a new element, we'd have to resize the array. We'll have a look at this in more detail later.</p>

</body>
</html>

